import torch
import torch.nn as nn
from models.backbone import PointNet2,PointNet
from models.common import compute_proposal,in_side,compute_target
from utils.anchor import NMS,align_anchor,assign_anchor
from models.group_pointcloud import preprocess,PointsPool
from utils.loss import BCEFocalLoss,BCE,Reg
import numpy as np
'''
classes
'Pedestrian','Cyclist','Car'
'''


class PGM(nn.Module):
    def __init__(self,cls):
        super(PGM, self).__init__()
        self.model = PointNet2(1)
        self.model2 = PointNet()
        self.cls = cls
        self.focal_loss = BCEFocalLoss()
        self.cls_loss = BCE()
        self.reg_loss = Reg()
    def forward(self,points,label):
        # xyz B,N,4
        scores, features = self.model(points)
        # for each batch
        B, N, C = scores.shape
        B, N, D = features.shape
        B, G, M = label.shape

        # single batch
        batch_id = 0
        score = scores[batch_id].view(1, N, C)
        feature = features[batch_id].view(1, N, D)
        ground_truth = label[batch_id].view(1, G, M)
        xyz = points[batch_id].view(1, N, 4)
        with torch.no_grad():
            anc,r,score_anc = NMS(score, xyz, self.cls)
            # get the input of PointNet per anchor
            anchor_points, anchor_masks = align_anchor(anc, r, xyz, feature)
            pos_mask, pos_number,pointwise = assign_anchor(ground_truth, anchor_masks, xyz)
        if self.training:
            pointwise_label = (pointwise > 0).float()
            ancwise_label = (pos_mask > 0).float()
            score_anc.requires_grad = True
            loss = self.focal_loss(score, pointwise_label)
            loss += self.cls_loss(score_anc, ancwise_label)
            loss_reg = torch.zeros(torch.Size((1,)), dtype=torch.float, requires_grad=True, device=loss.device)
        proposals = []
        judge_pos = (pos_mask > 0).cpu().numpy()
        N_pos = int(np.sum(judge_pos))
        for pts, center, is_pos,number in zip(anchor_points, anc,judge_pos,pos_number):  # to each anchor
            if is_pos:
                pts.requires_grad = True
                # using PointNet to predict the proposal
                pred_reg, pred_cls = self.model2(pts)
                if self.training:
                    # compute loss
                    targets = compute_target(ground_truth,center,self.cls)
                    loss_reg += self.reg_loss(pred_reg,pred_cls,targets)
                pp = compute_proposal(pred_reg, pred_cls, center, self.cls)
                proposals.append(pp)
        if self.training and N_pos:
            loss_reg /= N_pos
        if self.training:
            return proposals,features,loss+loss_reg
        else:
            return proposals, features

class STD(nn.Module):
    def __init__(self):
        super(STD, self).__init__()
        self.model3 = PointsPool()
    def forward(self,proposals,xyz,features):
        '''
        :param proposals: the proposals generated by PGM P,7
        :param xyz: raw input B,N,4
        :param features: feature generated by PointNet++ B,N,128
        :return:
        '''
        # get all proposal (N,7)
        proposals = torch.cat(proposals, dim=0)
        proposal_points = in_side(xyz, features, proposals[:, :3], proposals[:, 3:6], proposals[:, 6], proposals[:, 7])
        # using NMS to delete extra proposal

        # PointsPool
        number, feature = preprocess(proposal_points, proposals)
        feature.requires_grad = True
        pred_proposal = self.model3(feature)


